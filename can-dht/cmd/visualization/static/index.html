<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CAN DHT Visualization</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/css/bootstrap.min.css">
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f8f9fa;
            margin: 0;
            padding: 0;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        .encrypted-pill {
            display: inline-block;
            background-color: #28a745;
            color: white;
            font-size: 8px;
            padding: 2px 6px;
            border-radius: 10px;
            margin-left: 3px;
            vertical-align: middle;
        }
        
        .replica-pill {
            display: inline-block;
            background-color: #6c757d;
            color: white;
            font-size: 8px;
            padding: 2px 6px;
            border-radius: 10px;
            margin-left: 3px;
            vertical-align: middle;
        }
        
        .replica-link {
            stroke: #6c757d;
            stroke-width: 1.5;
            stroke-dasharray: 4;
            pointer-events: none;
        }
        
        h1 {
            color: #343a40;
            text-align: center;
            margin-top: 20px;
            margin-bottom: 20px;
        }
        
        #visualization {
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
            overflow: hidden;
            position: relative;
        }
        
        /* Legend styles */
        .legend {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: rgba(255, 255, 255, 0.9);
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 8px;
            font-size: 12px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }
        
        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 5px;
        }
        
        .legend-label {
            font-size: 11px;
        }
        
        #controls {
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            padding: 20px;
            margin-bottom: 20px;
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        button {
            margin-right: 10px;
            margin-bottom: 10px;
        }
        
        .tooltip {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 12px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
        }
        
        .node-label {
            font-size: 12px;
            text-anchor: middle;
            fill: #343a40;
            pointer-events: none;
        }
        
        /* Key label styles */
        .key-text-bg {
            fill: rgba(255, 255, 255, 0.7);
            rx: 3;
            ry: 3;
        }
        
        .key-text {
            dominant-baseline: middle;
            pointer-events: none;
        }
        
        /* Information panel styles */
        #info-panel {
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            padding: 20px;
        }
        
        .info-title {
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 10px;
        }
        
        .info-content {
            font-size: 14px;
            line-height: 1.5;
        }
        
        /* Key-value operation form */
        #kv-operations {
            margin-top: 20px;
        }
        
        /* Button disabled state styling */
        .disabled-btn {
            opacity: 0.6;
            cursor: not-allowed;
            pointer-events: none;
        }
        
        /* Force-enable class to override Bootstrap disabled state */
        .force-enable {
            opacity: 1 !important;
            cursor: pointer !important;
            pointer-events: auto !important;
            background-color: #28a745 !important;
            border-color: #28a745 !important;
            color: white !important;
        }
    </style>
</head>
<body>
    <div class="container mt-4">
        <h1>Content Addressable Network (CAN) DHT Visualization</h1>
        
        <div class="row">
            <div class="col-md-8">
                <!-- Visualization Area -->
                <div id="visualization"></div>
                
                <!-- Controls -->
                <div id="controls" class="mt-3">
                    <div class="control-group">
                        <h5>Network Operations</h5>
                        <button id="preview-join-btn" class="btn btn-outline-primary">Preview Join Point</button>
                        <button id="add-node-btn" class="btn btn-primary">Add Node</button>
                        <button id="reset-btn" class="btn btn-warning">Reset Simulation</button>
                    </div>
                    <div class="control-group">
                        <h5>Replication Settings</h5>
                        <div class="row mb-3">
                            <div class="col-md-6">
                                <div class="input-group">
                                    <span class="input-group-text">Default Factor</span>
                                    <input type="number" id="replication-factor" class="form-control" min="1" max="5" value="1">
                                    <button id="set-replication-btn" class="btn btn-secondary">Set</button>
                                </div>
                            </div>
                            <div class="col-md-6">
                                <div class="form-text">
                                    Number of copies (including primary) to maintain for new keys
                                </div>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-md-5">
                                <div class="input-group">
                                    <span class="input-group-text">Replicate Key</span>
                                    <input type="text" id="replicate-key-input" class="form-control" placeholder="Enter key name">
                                </div>
                            </div>
                            <div class="col-md-4">
                                <div class="input-group">
                                    <span class="input-group-text">Copies</span>
                                    <input type="number" id="key-replication-factor" class="form-control" min="1" max="5" value="2">
                                    <button id="replicate-key-btn" class="btn btn-info">Replicate</button>
                                </div>
                            </div>
                            <div class="col-md-3">
                                <div class="form-text">
                                    Replicate a specific key
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="control-group">
                        <h5>Key-Value Operations</h5>
                        <div class="row mb-3">
                            <div class="col-md-12">
                                <h6>PUT Operation</h6>
                            </div>
                            <div class="col-md-3">
                                <input type="text" id="put-key-input" class="form-control mb-2" placeholder="Key">
                            </div>
                            <div class="col-md-3">
                                <input type="text" id="put-value-input" class="form-control mb-2" placeholder="Value">
                            </div>
                            <div class="col-md-3">
                                <div class="form-check mt-2">
                                    <input class="form-check-input" type="checkbox" id="encrypt-checkbox">
                                    <label class="form-check-label" for="encrypt-checkbox">
                                        Encrypt
                                    </label>
                                </div>
                            </div>
                            <div class="col-md-3">
                                <button id="put-btn" class="btn btn-success">PUT</button>
                            </div>
                        </div>
                        
                        <div class="row">
                            <div class="col-md-12">
                                <h6>GET & DELETE Operations</h6>
                            </div>
                            <div class="col-md-6">
                                <input type="text" id="get-key-input" class="form-control mb-2" placeholder="Key">
                            </div>
                            <div class="col-md-6">
                                <button id="get-btn" class="btn btn-info">GET</button>
                                <button id="delete-btn" class="btn btn-danger">DELETE</button>
                            </div>
                        </div>
                    </div>
                    <div class="control-group">
                        <h5>Fault Tolerance</h5>
                        <div class="row mb-3">
                            <div class="col-md-6">
                                <div class="input-group">
                                    <span class="input-group-text">Node</span>
                                    <select id="node-select" class="form-select">
                                        <option value="">Select a node...</option>
                                    </select>
                                </div>
                            </div>
                            <div class="col-md-6">
                                <button id="fail-node-btn" class="btn btn-danger">Fail Node</button>
                                <button id="recover-node-btn" class="btn btn-success">Recover Node</button>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-12">
                                <div class="form-text mb-2">
                                    Simulate node failures and recoveries to test fault tolerance
                                </div>
                                <div id="fault-tolerance-status" class="alert alert-info d-none">
                                    Status information will appear here
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="col-md-4">
                <!-- Information Panel -->
                <div id="info-panel">
                    <div class="info-title">System Information</div>
                    <div class="info-content">
                        <div>Nodes: <span id="node-count">0</span></div>
                        <div>Key-Value Pairs: <span id="kv-count">0</span></div>
                        <div class="mt-3">Last Action:</div>
                        <div id="last-action">None</div>
                    </div>
                    
                    <hr>
                    
                    <div class="info-title">Selected Entity Info</div>
                    <div id="selected-info" class="info-content">
                        <em>Click on a node or key-value pair for details</em>
                    </div>
                    
                    <hr>
                    
                    <div class="info-title">CAN DHT Explanation</div>
                    <div class="info-content">
                        <p>A Content Addressable Network (CAN) is a distributed hash table that maps keys to values in a multi-dimensional coordinate space.</p>
                        <p><strong>Nodes:</strong> Each node owns a zone in the coordinate space.</p>
                        <p><strong>Key-Value Pairs:</strong> Keys are hashed to coordinate points and stored on the responsible node.</p>
                        <p><strong>Routing:</strong> Requests are routed through neighbors based on their proximity to the target point.</p>
                        <p><strong>Node Joining:</strong> When a new node joins, it:</p>
                        <ol style="padding-left: 20px; margin-top: 0;">
                            <li>Picks a random point in the space (yellow flash)</li>
                            <li>The node owning that point splits its zone</li>
                            <li>The new node takes one half of the split zone</li>
                            <li>Key-value pairs are redistributed accordingly</li>
                        </ol>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Tooltip -->
    <div id="tooltip" class="tooltip"></div>
    
    <script>
        // Configuration
        const config = {
            width: 800,
            height: 600,
            padding: 40,
            refreshInterval: 1000, // ms
            nodeRadius: 8,
            keyRadius: 8, // Increased size
            replicaKeyRadius: 6, // Slightly smaller for replicas
            pathDuration: 5000, // ms
            primaryStroke: "#000", // Black stroke for primary keys
            replicaStroke: "#6c757d", // Gray stroke for replicas
            primaryStrokeWidth: 2, // Thicker stroke for primary
            replicaStrokeWidth: 1.5 // Thinner stroke for replicas
        };
        
        // State
        let state = {
            nodes: [],
            keyValuePairs: [],
            routingPaths: [],
            selectedEntity: null,
            joinPoints: {}, // Track join points by node ID
            replicationFactor: 1, // Current replication factor
        };
        
        // Create SVG element
        const svg = d3.select("#visualization")
            .append("svg")
            .attr("width", config.width)
            .attr("height", config.height);
        
        // Create a group for zones
        const zonesGroup = svg.append("g").attr("class", "zones");
        
        // Create a group for routing paths
        const pathsGroup = svg.append("g").attr("class", "paths");
        
        // Create a group for nodes
        const nodesGroup = svg.append("g").attr("class", "nodes");
        
        // Create a group for key-value pairs
        const keysGroup = svg.append("g").attr("class", "keys");
        
        // Add legend
        const legend = svg.append("g")
            .attr("class", "legend")
            .attr("transform", `translate(${config.width - 120}, 20)`);
            
        legend.append("rect")
            .attr("width", 110)
            .attr("height", 85)
            .attr("fill", "rgba(255, 255, 255, 0.9)")
            .attr("rx", 4)
            .attr("ry", 4)
            .attr("stroke", "#ddd")
            .attr("stroke-width", 1);
            
        // Legend title
        legend.append("text")
            .attr("x", 55)
            .attr("y", 20)
            .attr("text-anchor", "middle")
            .attr("font-size", "12px")
            .attr("font-weight", "bold")
            .text("Legend");
            
        // Primary key
        const primaryLegend = legend.append("g").attr("transform", "translate(10, 35)");
        primaryLegend.append("circle")
            .attr("r", 6)
            .attr("fill", "#ff5733")
            .attr("stroke", config.primaryStroke)
            .attr("stroke-width", config.primaryStrokeWidth);
        primaryLegend.append("text")
            .attr("x", 15)
            .attr("y", 4)
            .attr("font-size", "11px")
            .text("Primary Key");
            
        // Replica key
        const replicaLegend = legend.append("g").attr("transform", "translate(10, 55)");
        replicaLegend.append("circle")
            .attr("r", 5)
            .attr("fill", "#ff5733")
            .attr("stroke", config.replicaStroke)
            .attr("stroke-width", config.replicaStrokeWidth)
            .attr("opacity", 0.7);
        replicaLegend.append("text")
            .attr("x", 15)
            .attr("y", 4)
            .attr("font-size", "11px")
            .text("Replica Key");
            
        // Replication link
        const linkLegend = legend.append("g").attr("transform", "translate(10, 75)");
        linkLegend.append("line")
            .attr("x1", 0)
            .attr("y1", 0)
            .attr("x2", 12)
            .attr("y2", 0)
            .attr("stroke", "#6c757d")
            .attr("stroke-width", 1.5)
            .attr("stroke-dasharray", "3");
        linkLegend.append("text")
            .attr("x", 15)
            .attr("y", 4)
            .attr("font-size", "11px")
            .text("Replica Link");
        
        // Create coordinate axes
        const xAxis = d3.scaleLinear()
            .domain([0, 1])
            .range([config.padding, config.width - config.padding]);
        
        const yAxis = d3.scaleLinear()
            .domain([0, 1])
            .range([config.height - config.padding, config.padding]);
        
        // Add X axis
        svg.append("g")
            .attr("transform", `translate(0,${config.height - config.padding})`)
            .call(d3.axisBottom(xAxis).ticks(10));
        
        // Add Y axis
        svg.append("g")
            .attr("transform", `translate(${config.padding},0)`)
            .call(d3.axisLeft(yAxis).ticks(10));
        
        // Tooltip
        const tooltip = d3.select("#tooltip");
        
        // Fetch state from server
        function fetchState() {
            fetch("/api/state")
                .then(response => response.json())
                .then(data => {
                    console.log('========== RECEIVED STATE DATA ==========');
                    console.log('Raw response data:', data);
                    
                    // Check the format of failedNodes from server
                    console.log('Failed nodes from server:', data.failedNodes);
                    console.log('Type of failedNodes:', typeof data.failedNodes);
                    console.log('Is array?', Array.isArray(data.failedNodes));
                    
                    // Ensure failedNodes is properly initialized as an array
                    if (!data.failedNodes) {
                        console.log('No failedNodes in response, initializing empty array');
                        data.failedNodes = [];
                    } else if (!Array.isArray(data.failedNodes)) {
                        console.log('failedNodes is not an array, converting to array');
                        // Convert to array if it's not already one
                        if (typeof data.failedNodes === 'object') {
                            data.failedNodes = Object.keys(data.failedNodes);
                        } else {
                            data.failedNodes = [data.failedNodes];
                        }
                    }
                    
                    // Update state
                    state = data;
                    
                    console.log('Final state.failedNodes:', state.failedNodes);
                    console.log('Number of failed nodes:', state.failedNodes.length);
                    
                    // Log each failed node separately for clarity
                    if (state.failedNodes.length > 0) {
                        console.log('Failed nodes:');
                        state.failedNodes.forEach((nodeId, idx) => {
                            console.log(`[${idx}] ${nodeId} (type: ${typeof nodeId})`);
                        });
                    } else {
                        console.log('No failed nodes');
                    }
                    
                    // Apply special styling to keys on failed nodes
                    highlightKeysOnFailedNodes();
                    
                    // Redraw visualization
                    updateVisualization();
                    
                    // Update node select dropdown for fault tolerance
                    updateNodeSelect();
                    
                    // Check if currently selected node is failed and force update buttons
                    const nodeSelect = document.getElementById('node-select');
                    if (nodeSelect && nodeSelect.value) {
                        const selectedNodeId = nodeSelect.value;
                        const isFailed = state.failedNodes.some(failedId => 
                            String(failedId) === String(selectedNodeId)
                        );
                        
                        console.log(`Currently selected node ${selectedNodeId} is ${isFailed ? 'FAILED' : 'ACTIVE'}`);
                        
                        // Force update button states based on node status
                        forceUpdateButtonsForFailedNode(selectedNodeId, isFailed);
                    }
                    
                    // Show system info
                    updateInfoPanel();
                })
                .catch(err => {
                    console.error('Error fetching state:', err);
                });
        }
        
        // Update the visualization based on current state
        function updateVisualization() {
            console.log("Updating visualization with:", state.keyValuePairs.length, "key-value pairs");
            
            // Debug: Print key-value pairs used for visualization
            const primaries = state.keyValuePairs.filter(kv => kv.IsPrimaryCopy).length;
            const replicas = state.keyValuePairs.filter(kv => !kv.IsPrimaryCopy).length;
            console.log(`Visualizing: ${primaries} primary keys and ${replicas} replica keys`);
            
            // Clear any existing paths first to ensure old paths don't persist
            pathsGroup.selectAll(".routing-path").remove();
            pathsGroup.selectAll("path[marker-end='url(#arrow)']").remove();
            
            // Update zones
            const zones = zonesGroup.selectAll(".zone")
                .data(state.nodes, d => d.id);
            
            zones.exit().remove();
            
            const newZones = zones.enter()
                .append("rect")
                .attr("class", "zone");
            
            zones.merge(newZones)
                .attr("x", d => xAxis(d.zone.MinPoint[0]))
                .attr("y", d => yAxis(d.zone.MaxPoint[1]))
                .attr("width", d => xAxis(d.zone.MaxPoint[0]) - xAxis(d.zone.MinPoint[0]))
                .attr("height", d => yAxis(d.zone.MinPoint[1]) - yAxis(d.zone.MaxPoint[1]))
                .attr("fill", "none")
                .attr("stroke", "#007BFF")
                .attr("stroke-width", 2)
                .attr("opacity", 0.7)
                .on("mouseover", function(event, d) {
                    d3.select(this).attr("stroke", "#0056b3").attr("stroke-width", 3);
                    showTooltip(event, `Node: ${d.id}<br>Zone: (${d.zone.MinPoint[0].toFixed(2)},${d.zone.MinPoint[1].toFixed(2)}) to (${d.zone.MaxPoint[0].toFixed(2)},${d.zone.MaxPoint[1].toFixed(2)})`);
                })
                .on("mouseout", function() {
                    d3.select(this).attr("stroke", "#007BFF").attr("stroke-width", 2);
                    hideTooltip();
                })
                .on("click", function(event, d) {
                    selectEntity({ type: "node", data: d });
                });
            
            // Update nodes
            const nodes = nodesGroup.selectAll(".node")
                .data(state.nodes, d => d.id);
            
            nodes.exit().remove();
            
            const newNodes = nodes.enter()
                .append("circle")
                .attr("class", "node");
            
            nodes.merge(newNodes)
                .attr("cx", d => xAxis((d.zone.MinPoint[0] + d.zone.MaxPoint[0]) / 2))
                .attr("cy", d => yAxis((d.zone.MinPoint[1] + d.zone.MaxPoint[1]) / 2))
                .attr("r", config.nodeRadius)
                .attr("fill", d => state.failedNodes && state.failedNodes.includes(d.id) ? "#f44336" : "#007BFF")
                .attr("stroke", "#fff")
                .attr("stroke-width", 2)
                .attr("stroke-dasharray", d => state.failedNodes && state.failedNodes.includes(d.id) ? "5,5" : "none")
                .on("mouseover", function(event, d) {
                    d3.select(this).attr("r", config.nodeRadius * 1.2);
                    showTooltip(event, `Node: ${d.id}`);
                })
                .on("mouseout", function() {
                    d3.select(this).attr("r", config.nodeRadius);
                    hideTooltip();
                })
                .on("click", function(event, d) {
                    selectEntity({ type: "node", data: d });
                });
            
            // Update node labels
            const nodeLabels = nodesGroup.selectAll(".node-label")
                .data(state.nodes, d => d.id);
            
            nodeLabels.exit().remove();
            
            const newNodeLabels = nodeLabels.enter()
                .append("text")
                .attr("class", "node-label");
            
            nodeLabels.merge(newNodeLabels)
                .attr("x", d => xAxis((d.zone.MinPoint[0] + d.zone.MaxPoint[0]) / 2))
                .attr("y", d => yAxis((d.zone.MinPoint[1] + d.zone.MaxPoint[1]) / 2) - config.nodeRadius - 5)
                .text(d => d.id + (state.failedNodes && state.failedNodes.includes(d.id) ? " (FAILED)" : ""))
                .attr("text-anchor", "middle");
            
            // Update key-value pairs
            console.log("Rendering key-value pairs...");
            const keys = keysGroup.selectAll(".key")
                .data(state.keyValuePairs, d => d.Key + (d.IsPrimaryCopy ? "" : "_replica_" + d.NodeID));
            
            const exitingKeys = keys.exit();
            console.log(`Removing ${exitingKeys.size()} old keys`);
            exitingKeys.remove();
            
            const newKeys = keys.enter()
                .append("circle")
                .attr("class", d => d.IsPrimaryCopy ? "key primary" : "key replica");
            
            // Process failed nodes with the updateNodesForFaultTolerance function
            updateNodesForFaultTolerance(nodes.merge(newNodes));
            
            console.log(`Adding ${newKeys.size()} new keys`);
            
            // Helper function to darken a color for replicas
            function adjustReplicaColor(color) {
                // Try to parse the color
                const hexMatch = color.match(/^#([0-9a-f]{6})$/i);
                if (hexMatch) {
                    // It's a hex color, darken it
                    const hex = hexMatch[1];
                    const r = parseInt(hex.slice(0, 2), 16);
                    const g = parseInt(hex.slice(2, 4), 16);
                    const b = parseInt(hex.slice(4, 6), 16);
                    
                    // Darken by 30%
                    const darkenFactor = 0.7;
                    const dr = Math.floor(r * darkenFactor);
                    const dg = Math.floor(g * darkenFactor);
                    const db = Math.floor(b * darkenFactor);
                    
                    return `#${dr.toString(16).padStart(2, '0')}${dg.toString(16).padStart(2, '0')}${db.toString(16).padStart(2, '0')}`;
                }
                return color; // Return unchanged if not a hex color
            }
            
            keys.merge(newKeys)
                .attr("cx", d => xAxis(d.Point[0]))
                .attr("cy", d => yAxis(d.Point[1]))
                .attr("r", d => d.IsPrimaryCopy ? config.keyRadius : config.replicaKeyRadius)
                .attr("fill", d => d.IsPrimaryCopy ? d.Color : adjustReplicaColor(d.Color))
                .attr("stroke", d => d.IsPrimaryCopy ? config.primaryStroke : config.replicaStroke)
                .attr("stroke-width", d => d.IsPrimaryCopy ? config.primaryStrokeWidth : config.replicaStrokeWidth)
                .style("opacity", d => d.IsPrimaryCopy ? 1 : 0.9)
                .on("mouseover", function(event, d) {
                    d3.select(this).attr("r", d.IsPrimaryCopy ? config.keyRadius * 1.5 : config.replicaKeyRadius * 1.5);
                    let tooltipText = `Key: ${d.Key}<br>Value: ${d.Value}`;
                    
                    if (d.Encrypted) {
                        tooltipText += '<br><span class="encrypted-pill">ENCRYPTED</span>';
                    }
                    
                    if (d.onFailedNode) {
                        tooltipText += '<br><span style="color:#f44336;font-weight:bold;">‚ö†Ô∏è ON FAILED NODE</span>';
                        
                        if (d.IsPrimaryCopy) {
                            if (d.hasHealthyReplica) {
                                tooltipText += '<br><span style="color:#ff9800;">This key has healthy replicas available</span>';
                            } else {
                                tooltipText += '<br><span style="color:#f44336;">No healthy replicas available!</span>';
                            }
                        } else {
                            tooltipText += '<br><span style="color:#ff9800;">This is a replica on a failed node</span>';
                        }
                    }
                    
                    if (!d.IsPrimaryCopy) {
                        tooltipText += '<br><span class="replica-pill">REPLICA</span>';
                        tooltipText += `<br>Primary Node: ${d.ReplicaOf || "Unknown"}`;
                        tooltipText += `<br>Stored on Node: ${d.NodeID}`;
                    } else if (d.ReplicaNodes && d.ReplicaNodes.length > 0) {
                        tooltipText += `<br>Replicated to ${d.ReplicaNodes.length} node(s)`;
                        tooltipText += `<br>Replica Nodes: ${d.ReplicaNodes.join(", ")}`;
                    }
                    showTooltip(event, tooltipText);
                })
                .on("mouseout", function(event, d) {
                    d3.select(this).attr("r", d.IsPrimaryCopy ? config.keyRadius : config.replicaKeyRadius);
                    hideTooltip();
                })
                .on("click", function(event, d) {
                    selectEntity({ type: "keyValue", data: d });
                });
            
            // Add pulsing animation to newly added replica keys
            newKeys.filter(d => !d.IsPrimaryCopy)
                .style("opacity", 0.3)
                .transition()
                .duration(500)
                .style("opacity", 1)
                .attr("r", config.replicaKeyRadius * 2)
                .transition()
                .duration(500)
                .attr("r", config.replicaKeyRadius)
                .style("opacity", 0.9);
            
            // Add replication links between primary and replica nodes
            if (state.replicationFactor > 1) {
                // Remove any existing links
                pathsGroup.selectAll(".replica-link").remove();
                
                // Create links for each primary copy that has replicas
                state.keyValuePairs.filter(kv => kv.IsPrimaryCopy && kv.ReplicaNodes && kv.ReplicaNodes.length > 0).forEach(primaryKV => {
                    // Find primary key point
                    const primaryPoint = {
                        x: xAxis(primaryKV.Point[0]),
                        y: yAxis(primaryKV.Point[1])
                    };
                    
                    // Find all replicas of this key
                    const replicas = state.keyValuePairs.filter(kv => 
                        !kv.IsPrimaryCopy && 
                        kv.Key === primaryKV.Key);
                    
                    // Draw line to each replica
                    replicas.forEach(replicaKV => {
                        const replicaPoint = {
                            x: xAxis(replicaKV.Point[0]),
                            y: yAxis(replicaKV.Point[1])
                        };
                        
                        // Add the link
                        pathsGroup.append("line")
                            .attr("class", "replica-link")
                            .attr("x1", primaryPoint.x)
                            .attr("y1", primaryPoint.y)
                            .attr("x2", replicaPoint.x)
                            .attr("y2", replicaPoint.y)
                            .attr("stroke", "#6c757d")
                            .attr("stroke-width", 2)
                            .attr("stroke-dasharray", "4")
                            .attr("opacity", 0.9)
                            .on("mouseover", function(event) {
                                d3.select(this)
                                    .attr("stroke-width", 3)
                                    .attr("opacity", 1);
                                showTooltip(event, `Replication link:<br>${primaryKV.Key} on ${primaryKV.NodeID} ‚Üí ${replicaKV.NodeID}`);
                            })
                            .on("mouseout", function() {
                                d3.select(this)
                                    .attr("stroke-width", 2)
                                    .attr("opacity", 0.9);
                                hideTooltip();
                            });
                            
                        // Add arrowhead to indicate replication direction
                        pathsGroup.append("polygon")
                            .attr("points", "0,-4 8,0 0,4")
                            .attr("fill", "#6c757d")
                            .attr("opacity", 0.9)
                            .attr("transform", function() {
                                // Calculate the position and rotation for the arrowhead
                                const angle = Math.atan2(replicaPoint.y - primaryPoint.y, replicaPoint.x - primaryPoint.x) * 180 / Math.PI;
                                const midX = (primaryPoint.x + replicaPoint.x) / 2;
                                const midY = (primaryPoint.y + replicaPoint.y) / 2;
                                return `translate(${midX},${midY}) rotate(${angle})`;
                            });
                    });
                });
            }
            
            // Add key labels
            const keyLabels = keysGroup.selectAll(".key-label")
                .data(state.keyValuePairs, d => d.Key + (d.IsPrimaryCopy ? "" : "_replica_" + d.NodeID));
                
            keyLabels.exit().remove();
            
            const newKeyLabels = keyLabels.enter()
                .append("g")
                .attr("class", "key-label");
            
            // Add the background rect for text
            newKeyLabels.append("rect")
                .attr("class", "key-text-bg");
                
            // Add the main text element for the key
            newKeyLabels.append("text")
                .attr("class", "key-text")
                .attr("pointer-events", "none");
            
            // Update all labels
            keyLabels.merge(newKeyLabels)
                .attr("transform", d => `translate(${xAxis(d.Point[0]) + config.keyRadius + 5}, ${yAxis(d.Point[1])})`);
            
            // Update the text for all labels
            const textElements = keyLabels.merge(newKeyLabels).select(".key-text")
                .text(d => d.Key)
                .attr("font-size", "12px")
                .attr("font-weight", d => d.IsPrimaryCopy ? "bold" : "normal")
                .attr("fill", d => d.IsPrimaryCopy ? "#333" : "#666")
                .attr("opacity", d => d.IsPrimaryCopy ? 1 : 0.8)
                .attr("y", 0) // Center vertically
                .attr("x", 3); // Add a little padding
                
            // Update background rectangles for each text
            keyLabels.merge(newKeyLabels).select(".key-text-bg")
                .each(function(d, i) {
                    const textElement = d3.select(this.parentNode).select(".key-text").node();
                    const textWidth = textElement.getComputedTextLength();
                    
                    d3.select(this)
                        .attr("width", textWidth + 6) // Add padding
                        .attr("height", 18) // Fixed height
                        .attr("y", -9) // Center vertically (half of height)
                        .attr("x", 0); // Start at the beginning
                });
            
            // Add or update the encryption indicator and replica count
            keyLabels.merge(newKeyLabels).each(function(d) {
                const g = d3.select(this);
                
                // Encryption lock
                let lock = g.select(".encryption-lock");
                if (d.Encrypted) {
                    if (lock.empty()) {
                        g.append("text")
                            .attr("class", "encryption-lock")
                            .attr("dx", function() { return d.Key.length * 5.5; })
                            .attr("dy", 0)
                            .attr("font-size", "10px")
                            .attr("fill", "#28a745")
                            .text("üîí");
                    }
                } else {
                    if (!lock.empty()) {
                        lock.remove();
                    }
                }
                
                // Replica count
                let replicaCount = g.select(".replica-count");
                if (d.ReplicaNodes && d.ReplicaNodes.length > 0) {
                    if (replicaCount.empty()) {
                        const offset = d.Encrypted ? d.Key.length * 5.5 + 15 : d.Key.length * 5.5;
                        g.append("text")
                            .attr("class", "replica-count")
                            .attr("dx", offset)
                            .attr("dy", 0)
                            .attr("font-size", "10px")
                            .attr("fill", "#6c757d")
                            .text(`üîÑ${d.ReplicaNodes.length}`);
                    } else {
                        replicaCount.text(`üîÑ${d.ReplicaNodes.length}`);
                    }
                } else {
                    if (!replicaCount.empty()) {
                        replicaCount.remove();
                    }
                }
            });
            
            // Update routing paths
            const paths = pathsGroup.selectAll(".routing-path")
                .data(state.routingPaths, (d, i) => `${d.RequestType}-${d.Key}-${i}`);
            
            paths.exit().remove();
            
            state.routingPaths.forEach((routingPath, pathIndex) => {
                if (routingPath.Path.length <= 1) return;
                
                // Create path points
                const pathPoints = [];
                for (let i = 0; i < routingPath.Path.length; i++) {
                    const nodeId = routingPath.Path[i];
                    const node = state.nodes.find(n => n.id === nodeId);
                    if (node) {
                        pathPoints.push({
                            x: xAxis((node.zone.MinPoint[0] + node.zone.MaxPoint[0]) / 2),
                            y: yAxis((node.zone.MinPoint[1] + node.zone.MaxPoint[1]) / 2)
                        });
                    }
                }
                
                if (pathPoints.length <= 1) return;
                
                // Create line function
                const lineFunction = d3.line()
                    .x(d => d.x)
                    .y(d => d.y)
                    .curve(d3.curveLinear);
                
                // Check if we need to create a new path
                let path = pathsGroup.select(`.routing-path-${pathIndex}`);
                if (path.empty()) {
                    // Create path element
                    path = pathsGroup.append("path")
                        .attr("class", `routing-path routing-path-${pathIndex}`)
                        .attr("d", lineFunction(pathPoints))
                        .attr("fill", "none")
                        .attr("stroke", getColorForRequestType(routingPath.RequestType))
                        .attr("stroke-width", 3)
                        .attr("stroke-dasharray", getTotalLength => {
                            const totalLength = path.node().getTotalLength();
                            return `${totalLength} ${totalLength}`;
                        })
                        .attr("stroke-dashoffset", path => path.node().getTotalLength())
                        .attr("opacity", 0.7);
                    
                    // Animate the path
                    path.transition()
                        .duration(config.pathDuration)
                        .attr("stroke-dashoffset", 0)
                        .on("end", function() {
                            // Fade out after completion
                            d3.select(this)
                                .transition()
                                .duration(1000)
                                .attr("opacity", 0)
                                .remove();
                        });
                    
                    // Add route markers (arrows)
                    for (let i = 0; i < pathPoints.length - 1; i++) {
                        const p1 = pathPoints[i];
                        const p2 = pathPoints[i + 1];
                        
                        // Calculate angle for the arrow
                        const angle = Math.atan2(p2.y - p1.y, p2.x - p1.x) * 180 / Math.PI;
                        
                        // Calculate midpoint for the arrow
                        const midX = (p1.x + p2.x) / 2;
                        const midY = (p1.y + p2.y) / 2;
                        
                        // Add arrow marker
                        pathsGroup.append("path")
                            .attr("d", "M0,-5L10,0L0,5")
                            .attr("fill", getColorForRequestType(routingPath.RequestType))
                            .attr("transform", `translate(${midX},${midY}) rotate(${angle})`)
                            .attr("opacity", 0)
                            .transition()
                            .delay((config.pathDuration / pathPoints.length) * i)
                            .duration(500)
                            .attr("opacity", 1)
                            .transition()
                            .delay(config.pathDuration - (config.pathDuration / pathPoints.length) * i)
                            .duration(500)
                            .attr("opacity", 0)
                            .remove();
                    }
                }
            });
        }
        
        // Helper function to get color for request type
        function getColorForRequestType(requestType) {
            switch (requestType) {
                case "PUT": return "#28a745";
                case "GET": return "#17a2b8";
                case "DELETE": return "#dc3545";
                default: return "#6c757d";
            }
        }
        
        // Show tooltip
        function showTooltip(event, text) {
            tooltip
                .style("opacity", 1)
                .style("left", (event.pageX + 10) + "px")
                .style("top", (event.pageY - 20) + "px")
                .html(text);
        }
        
        // Hide tooltip
        function hideTooltip() {
            tooltip.style("opacity", 0);
        }
        
        // Update info panel
        function updateInfoPanel() {
            document.getElementById("node-count").textContent = state.nodes.length;
            
            // Count primary key-value pairs only
            const primaryKeyCount = state.keyValuePairs.filter(kv => kv.IsPrimaryCopy).length;
            document.getElementById("kv-count").textContent = primaryKeyCount;
            
            document.getElementById("replication-factor").value = state.replicationFactor;
            
            // Update selected entity info
            if (state.selectedEntity) {
                let infoHtml = "";
                if (state.selectedEntity.type === "node") {
                    const node = state.selectedEntity.data;
                    
                    // Count primary and replica KV pairs in this node
                    const primaryKVs = state.keyValuePairs.filter(kv => kv.NodeID === node.id && kv.IsPrimaryCopy);
                    const replicaKVs = state.keyValuePairs.filter(kv => kv.NodeID === node.id && !kv.IsPrimaryCopy);
                    
                    infoHtml = `
                        <strong>Node ID:</strong> ${node.id}<br>
                        <strong>Address:</strong> ${node.address}<br>
                        <strong>Zone:</strong> (${node.zone.MinPoint[0].toFixed(3)}, ${node.zone.MinPoint[1].toFixed(3)}) to 
                        (${node.zone.MaxPoint[0].toFixed(3)}, ${node.zone.MaxPoint[1].toFixed(3)})<br>
                        <strong>Neighbors:</strong> ${node.neighbors.join(", ") || "None"}<br>
                        <strong>Primary KV Pairs:</strong> ${primaryKVs.length}<br>
                        <strong>Replica KV Pairs:</strong> ${replicaKVs.length}
                    `;
                } else if (state.selectedEntity.type === "keyValue") {
                    const kv = state.selectedEntity.data;
                    infoHtml = `
                        <strong>Key:</strong> ${kv.Key}<br>
                        <strong>Value:</strong> ${kv.Value}<br>
                        <strong>Coordinates:</strong> (${kv.Point[0].toFixed(3)}, ${kv.Point[1].toFixed(3)})<br>
                        <strong>Stored on Node:</strong> ${kv.NodeID}<br>
                    `;
                    
                    if (kv.Encrypted) {
                        infoHtml += `<strong>Security:</strong> <span style="color: #28a745;">üîí Encrypted</span><br>`;
                    }
                    
                    if (kv.IsPrimaryCopy) {
                        infoHtml += `<strong>Type:</strong> Primary Copy<br>`;
                        if (kv.ReplicaNodes && kv.ReplicaNodes.length > 0) {
                            infoHtml += `<strong>Replicated to:</strong> ${kv.ReplicaNodes.join(", ")}<br>`;
                        }
                        
                        // Auto-fill the replication input when a key is selected
                        document.getElementById("replicate-key-input").value = kv.Key;
                    } else {
                        infoHtml += `<strong>Type:</strong> <span style="color: #6c757d;">Replica</span><br>`;
                    }
                }
                document.getElementById("selected-info").innerHTML = infoHtml;
            }
        }
        
        // Replicate a specific key
        function replicateKey() {
            const key = document.getElementById("replicate-key-input").value;
            const factor = parseInt(document.getElementById("key-replication-factor").value);
            
            if (!key) {
                alert("Please enter a key to replicate");
                return;
            }
            
            if (isNaN(factor) || factor < 1) {
                alert("Replication factor must be at least 1");
                return;
            }
            
            fetch("/api/replication/replicate", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ key: key, replicas: factor })
            })
            .then(response => {
                if (response.status === 404) {
                    throw new Error("Key not found");
                }
                return response.json();
            })
            .then(data => {
                console.log("Replication response:", data);
                // Check for replicaNodes field with case-insensitive approach
                const replicaNodes = data.replicaNodes || data.ReplicaNodes;
                if (!replicaNodes) {
                    console.error("replicaNodes field is missing in the response:", JSON.stringify(data));
                    throw new Error("Response missing replicaNodes field");
                }
                document.getElementById("last-action").textContent = `Key '${key}' replicated to ${replicaNodes.length} nodes`;
                fetchState();
            })
            .catch(error => {
                console.error("Error replicating key:", error);
                document.getElementById("last-action").textContent = `Error replicating key: ${error.message}`;
                alert("Error replicating key: " + error.message);
            });
        }
        
        // Select an entity (node or key-value pair)
        function selectEntity(entity) {
            state.selectedEntity = entity;
            updateInfoPanel();
        }
        
        // Global variable to store the current preview point
        let currentPreviewPoint = null;
        let currentPreviewCircle = null;
        let currentPreviewLines = [];
        let currentPreviewArrows = [];
        
        // Preview a random join point
        function previewJoinPoint() {
            // Clear any existing preview
            clearJoinPreview();
            
            // Debug: output state to console
            console.log("Current state:", state);
            console.log("Nodes:", state.nodes);
            
            // Generate a new node ID for this potential join
            const potentialNodeId = `node-${state.nodes.length}`;
            
            // Check if a node is selected (to restrict join point to that node's zone)
            let ownerNode = null;
            let randomPoint;
            
            if (state.selectedEntity && state.selectedEntity.type === "node") {
                // A node is selected, use its zone to generate the join point
                ownerNode = state.selectedEntity.data;
                console.log("Using selected node for join point:", ownerNode.id);
                
                // Generate a random point within this node's zone
                const zone = ownerNode.zone;
                const minPoint = zone.MinPoint || zone.minPoint;
                const maxPoint = zone.MaxPoint || zone.maxPoint;
                
                // Check if we already have a join point for this node
                if (state.joinPoints[potentialNodeId]) {
                    // Check if the existing join point is within this zone
                    const existingPoint = state.joinPoints[potentialNodeId];
                    if (pointInZone(existingPoint, zone)) {
                        randomPoint = existingPoint;
                        console.log("Reusing existing join point in selected zone:", randomPoint);
                    } else {
                        // Generate a new point within this zone
                        randomPoint = [
                            minPoint[0] + Math.random() * (maxPoint[0] - minPoint[0]),
                            minPoint[1] + Math.random() * (maxPoint[1] - minPoint[1])
                        ];
                        state.joinPoints[potentialNodeId] = randomPoint;
                        console.log("Generated new join point in selected zone:", randomPoint);
                    }
                } else {
                    // Generate a new point within this zone
                    randomPoint = [
                        minPoint[0] + Math.random() * (maxPoint[0] - minPoint[0]),
                        minPoint[1] + Math.random() * (maxPoint[1] - minPoint[1])
                    ];
                    state.joinPoints[potentialNodeId] = randomPoint;
                    console.log("Generated new join point in selected zone:", randomPoint);
                }
            } else {
                // No node selected, use normal behavior
                // Check if we already have a join point for this node ID
                if (state.joinPoints[potentialNodeId]) {
                    // Reuse the existing join point
                    randomPoint = state.joinPoints[potentialNodeId];
                    console.log("Reusing existing join point for", potentialNodeId, ":", randomPoint);
                } else {
                    // Generate a new random point
                    randomPoint = [Math.random(), Math.random()];
                    // Store it for future use
                    state.joinPoints[potentialNodeId] = randomPoint;
                    console.log("Generated new join point for", potentialNodeId, ":", randomPoint);
                }
                
                // Find the node that owns this point
                if (Array.isArray(state.nodes)) {
                    // Check each node to see if it contains the point
                    for (let i = 0; i < state.nodes.length; i++) {
                        const node = state.nodes[i];
                        if (node && node.zone && pointInZone(randomPoint, node.zone)) {
                            ownerNode = node;
                            break;
                        }
                    }
                } else {
                    console.error("state.nodes is not an array:", typeof state.nodes);
                }
            }
            
            currentPreviewPoint = randomPoint;
            console.log("Random point:", randomPoint);
            
            if (!ownerNode) {
                console.error("Could not find a node that owns this point:", randomPoint);
                alert("Could not find a node that owns this point. Please try again.");
                return;
            }
            
            // Visualize the random point
            currentPreviewCircle = pathsGroup.append("circle")
                .attr("class", "preview-point")
                .attr("cx", xAxis(randomPoint[0]))
                .attr("cy", yAxis(randomPoint[1]))
                .attr("r", 8)
                .attr("fill", "rgba(255, 215, 0, 0.7)")
                .attr("stroke", "#FFD700")
                .attr("stroke-width", 2)
                .attr("opacity", 0);
            
            // Add pulsating animation for the point
            function pulsePreviewPoint() {
                currentPreviewCircle
                    .transition()
                    .duration(1000)
                    .attr("r", 12)
                    .attr("opacity", 0.9)
                    .transition()
                    .duration(1000)
                    .attr("r", 8)
                    .attr("opacity", 0.7)
                    .on("end", pulsePreviewPoint);
            }
            
            // Start with fade-in
            currentPreviewCircle
                .transition()
                .duration(500)
                .attr("opacity", 0.7)
                .on("end", pulsePreviewPoint);
            
            // Create tooltip text
            const tooltipText = `Random Join Point (${randomPoint[0].toFixed(3)}, ${randomPoint[1].toFixed(3)})<br>
                                <strong>This point is in node:</strong> ${ownerNode.id}<br>
                                <strong>If a node joins here:</strong> ${ownerNode.id}'s zone will split`;
            
            // Add mouse events for the preview point
            currentPreviewCircle
                .on("mouseover", function(event) {
                    showTooltip(event, tooltipText);
                })
                .on("mouseout", hideTooltip);
            
            // Highlight the owner node's zone by creating a highlight rect
            const nodeZone = ownerNode.zone;
            const minPoint = nodeZone.MinPoint || nodeZone.minPoint;
            const maxPoint = nodeZone.MaxPoint || nodeZone.maxPoint;
            
            // Create a highlight rect for the zone
            const highlightRect = zonesGroup.append("rect")
                .attr("class", "zone-highlight")
                .attr("x", xAxis(minPoint[0]))
                .attr("y", yAxis(maxPoint[1]))
                .attr("width", xAxis(maxPoint[0]) - xAxis(minPoint[0]))
                .attr("height", yAxis(minPoint[1]) - yAxis(maxPoint[1]))
                .attr("fill", "none")
                .attr("stroke", "#FFD700")
                .attr("stroke-width", 3)
                .attr("stroke-dasharray", "5,5")
                .attr("opacity", 0);
            
            currentPreviewLines.push(highlightRect);
            
            // Animate the highlight
            highlightRect.transition()
                .duration(500)
                .attr("opacity", 1);
            
            // Show arrow from point to node
            const nodeCenter = {
                x: xAxis((minPoint[0] + maxPoint[0]) / 2),
                y: yAxis((minPoint[1] + maxPoint[1]) / 2)
            };
            
            // Add an arrow pointing from the join point to the node
            const arrow = pathsGroup.append("path")
                .attr("d", `M${xAxis(randomPoint[0])},${yAxis(randomPoint[1])} L${nodeCenter.x},${nodeCenter.y}`)
                .attr("stroke", "#FFD700")
                .attr("stroke-width", 2)
                .attr("opacity", 0)
                .attr("fill", "none")
                .attr("marker-end", "url(#arrow)");
            
            currentPreviewArrows.push(arrow);
            
            // Add arrow marker definition if not already present
            if (svg.select("#arrow").empty()) {
                svg.append("defs").append("marker")
                    .attr("id", "arrow")
                    .attr("viewBox", "0 -5 10 10")
                    .attr("refX", 8)
                    .attr("refY", 0)
                    .attr("markerWidth", 6)
                    .attr("markerHeight", 6)
                    .attr("orient", "auto")
                    .append("path")
                    .attr("d", "M0,-5L10,0L0,5")
                    .attr("fill", "#FFD700");
            }
            
            // Animate the arrow
            arrow.transition()
                .duration(1000)
                .attr("opacity", 0.8);
            
            // Add text to explain
            const infoText = pathsGroup.append("text")
                .attr("x", xAxis(randomPoint[0]) + 20)
                .attr("y", yAxis(randomPoint[1]) - 15)
                .attr("fill", "#333")
                .attr("font-size", "12px")
                .attr("opacity", 0)
                .text("Random join point");
            
            currentPreviewLines.push(infoText);
            
            infoText.transition()
                .duration(1000)
                .attr("opacity", 1);
            
            // Add text to explain the owner
            const ownerText = pathsGroup.append("text")
                .attr("x", nodeCenter.x + 15)
                .attr("y", nodeCenter.y - 15)
                .attr("fill", "#333")
                .attr("font-size", "12px")
                .attr("opacity", 0)
                .text(`Zone owner: ${ownerNode.id}`);
            
            currentPreviewLines.push(ownerText);
            
            ownerText.transition()
                .duration(1000)
                .attr("opacity", 1);
            
            // Update the last action text
            document.getElementById("last-action").innerHTML = `<strong>Preview:</strong> Random point (${randomPoint[0].toFixed(3)}, ${randomPoint[1].toFixed(3)}) selected in ${ownerNode.id}'s zone.<br>Click "Add Node" to complete the join operation.`;
        }
        
        // Clear any existing join preview
        function clearJoinPreview() {
            if (currentPreviewCircle) {
                currentPreviewCircle.remove();
                currentPreviewCircle = null;
            }
            
            // Remove any arrows
            currentPreviewArrows.forEach(arrow => arrow.remove());
            currentPreviewArrows = [];
            
            // Remove any text explanations and highlight rects
            currentPreviewLines.forEach(element => element.remove());
            currentPreviewLines = [];
            
            // We no longer need to reset zone strokes since we're using a separate highlight rect
        }
        
        // Helper function to check if a point is in a zone
        function pointInZone(point, zone) {
            // Debug what we're checking
            console.log("Checking point:", point, "against zone:", zone);
            
            // Make sure zone is valid
            if (!zone) {
                console.error("Invalid zone:", zone);
                return false;
            }
            
            // Handle both upper and lowercase property names
            const minPoint = zone.MinPoint || zone.minPoint;
            const maxPoint = zone.MaxPoint || zone.maxPoint;
            
            if (!minPoint || !maxPoint) {
                console.error("Zone missing min/max points:", zone);
                return false;
            }
            
            // Now check if the point is in the zone
            return point[0] >= minPoint[0] && 
                   point[0] < maxPoint[0] && 
                   point[1] >= minPoint[1] && 
                   point[1] < maxPoint[1];
        }
        
        // Add a new node
        function addNode() {
            // If we have a preview point, use it; otherwise generate a random point
            const usePreviewPoint = currentPreviewPoint !== null;
            const requestBody = {};
            
            if (usePreviewPoint) {
                requestBody.joinPoint = currentPreviewPoint;
            } else {
                // Generate a new random point if needed (but this should rarely happen)
                const randomPoint = [Math.random(), Math.random()];
                requestBody.joinPoint = randomPoint;
            }
            
            fetch("/api/node/add", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(requestBody)
            })
            .then(response => response.json())
            .then(data => {
                // Clear any existing preview
                clearJoinPreview();
                
                document.getElementById("last-action").textContent = `Added node: ${data.id}`;
                
                // Visualize the join point with a temporary highlight
                if (data.point) {
                    const joinPoint = pathsGroup.append("circle")
                        .attr("cx", xAxis(data.point[0]))
                        .attr("cy", yAxis(data.point[1]))
                        .attr("r", 10)
                        .attr("fill", "rgba(255, 255, 0, 0.5)")
                        .attr("stroke", "#FFD700")
                        .attr("stroke-width", 2)
                        .attr("opacity", 0);
                    
                    // Animate the join point
                    joinPoint.transition()
                        .duration(500)
                        .attr("opacity", 1)
                        .transition()
                        .duration(1000)
                        .attr("opacity", 0.8)
                        .transition()
                        .duration(500)
                        .attr("opacity", 0)
                        .on("end", function() {
                            joinPoint.remove();
                        });
                }
                
                // Reset current preview point
                currentPreviewPoint = null;
                
                fetchState();
            })
            .catch(error => console.error("Error adding node:", error));
        }
        
        // Reset the simulation
        function resetSimulation() {
            // Basic visual feedback
            const resetBtn = document.getElementById("reset-btn");
            resetBtn.disabled = true;
            resetBtn.textContent = "Resetting...";
            
            document.getElementById("last-action").textContent = "Resetting simulation...";
            
            // Clear any existing visualization items
            try {
                clearJoinPreview(); // Clear any join preview
                pathsGroup.selectAll("*").remove();
            } catch (e) {
                console.error("Error clearing visualization:", e);
            }
            
            // Simple fetch request without timeout signal
            fetch("/api/reset", {
                method: "POST",
                headers: {"Content-Type": "application/json"}
            })
            .then(response => response.json())
            .then(data => {
                // Reset state variables
                state.selectedEntity = null;
                state.joinPoints = {};
                state.routingPaths = [];
                
                // Clear input fields
                document.getElementById("put-key-input").value = "";
                document.getElementById("put-value-input").value = "";
                document.getElementById("get-key-input").value = "";
                document.getElementById("encrypt-checkbox").checked = false;
                
                // Update UI
                document.getElementById("last-action").textContent = "Simulation reset complete";
                
                // Refresh the state
                fetchState();
            })
            .catch(error => {
                console.error("Reset error:", error);
                document.getElementById("last-action").textContent = "Reset failed - please refresh the page";
            })
            .finally(() => {
                // Re-enable button
                resetBtn.disabled = false;
                resetBtn.textContent = "Reset Simulation";
            });
        }
        
        // Put key-value pair
        function putKeyValue() {
            const key = document.getElementById("put-key-input").value;
            const value = document.getElementById("put-value-input").value;
            const encrypt = document.getElementById("encrypt-checkbox").checked;
            
            if (!key || !value) {
                alert("Please enter both key and value");
                return;
            }
            
            fetch("/api/kv/put", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ key, value, encrypt })
            })
            .then(response => response.json())
            .then(data => {
                const encryptedStatus = encrypt ? " (Encrypted)" : "";
                document.getElementById("last-action").textContent = `PUT: Key="${key}", Value="${value}"${encryptedStatus}`;
                fetchState();
            })
            .catch(error => console.error("Error putting key-value:", error));
        }
        
        // Get key-value pair
        function getKeyValue() {
            const key = document.getElementById("get-key-input").value;
            
            if (!key) {
                alert("Please enter a key");
                return;
            }
            
            document.getElementById("last-action").innerHTML = `Processing GET request for key "${key}"...`;
            
            fetch(`/api/kv/get/${key}`)
            .then(response => {
                if (response.status === 404) {
                    throw new Error("Key not found");
                }
                if (response.status === 503) {
                    return response.json().then(data => {
                        throw new Error(data.error || "Key unavailable due to node failure");
                    });
                }
                return response.json();
            })
            .then(data => {
                console.log("GET response:", data);
                
                let message = `GET: Key="${key}", Value="${data.value}"`;
                
                // Show if the value was retrieved from a replica
                if (data.fromReplica) {
                    message += `<br><span style="color:#ff9800;font-weight:bold;">‚ö†Ô∏è Retrieved from replica on node ${data.node}</span>`;
                    message += `<br><span style="color:#666;">Primary node is failed, using replica for fault tolerance</span>`;
                }
                
                document.getElementById("last-action").innerHTML = message;
                document.getElementById("put-value-input").value = data.value;
                
                // Checkbox should reflect the encryption status of the key
                document.getElementById("encrypt-checkbox").checked = data.encrypted || false;
                
                // Also update the put-key-input for convenience
                document.getElementById("put-key-input").value = key;
                
                fetchState();
            })
            .catch(error => {
                console.error("Error getting key-value:", error);
                let errorMsg = `<span style="color:#f44336;font-weight:bold;">GET ERROR: ${error.message}</span>`;
                
                if (error.message.includes("unavailable") || error.message.includes("failed")) {
                    errorMsg += `<br><span style="color:#666;">This key is unavailable because its primary node has failed.</span>`;
                    
                    if (error.message.includes("no replicas were created")) {
                        errorMsg += `<br><span style="color:#ff9800;font-weight:bold;">No replicas were created for this key before the node failed.</span>`;
                        errorMsg += `<br><span style="color:#666;">To enable fault tolerance, you must replicate keys BEFORE nodes fail:</span>`;
                        errorMsg += `<ol style="color:#666;margin-top:5px;">
                            <li>Select the key you want to replicate</li>
                            <li>Enter a replication factor (e.g., 2) under "Replicate Key"</li>
                            <li>Click the "Replicate" button</li>
                            <li>Then you can safely fail nodes while maintaining access to the key</li>
                        </ol>`;
                    } else if (error.message.includes("all replicas are also on failed nodes")) {
                        errorMsg += `<br><span style="color:#ff9800;font-weight:bold;">All replica nodes for this key have also failed.</span>`;
                        errorMsg += `<br><span style="color:#666;">For better fault tolerance, replicate keys to more nodes.</span>`;
                    }
                }
                
                document.getElementById("last-action").innerHTML = errorMsg;
                alert("Error: " + error.message);
            });
        }
        
        // Delete key-value pair
        function deleteKeyValue() {
            const key = document.getElementById("get-key-input").value;
            
            if (!key) {
                alert("Please enter a key");
                return;
            }
            
            fetch(`/api/kv/delete/${key}`, {
                method: "DELETE"
            })
            .then(response => {
                if (response.status === 404) {
                    throw new Error("Key not found");
                }
                return response.json();
            })
            .then(data => {
                document.getElementById("last-action").textContent = `DELETE: Key="${key}"`;
                document.getElementById("put-value-input").value = "";
                document.getElementById("put-key-input").value = "";
                document.getElementById("encrypt-checkbox").checked = false;
                fetchState();
            })
            .catch(error => {
                console.error("Error deleting key-value:", error);
                document.getElementById("last-action").textContent = `DELETE: Key="${key}" - Not found`;
                alert("Key not found");
            });
        }
        
        // Set replication factor
        function setReplicationFactor() {
            const factor = parseInt(document.getElementById("replication-factor").value);
            
            if (isNaN(factor) || factor < 1) {
                alert("Replication factor must be at least 1");
                return;
            }
            
            fetch("/api/replication/factor", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ factor: factor })
            })
            .then(response => response.json())
            .then(data => {
                document.getElementById("last-action").textContent = `Replication factor set to ${factor}`;
                fetchState();
            })
            .catch(error => console.error("Error setting replication factor:", error));
        }
        
        // Initialize the application
        function init() {
            // Attach event listeners
            document.getElementById("preview-join-btn").addEventListener("click", previewJoinPoint);
            document.getElementById("add-node-btn").addEventListener("click", addNode);
            document.getElementById("reset-btn").addEventListener("click", resetSimulation);
            document.getElementById("put-btn").addEventListener("click", putKeyValue);
            document.getElementById("get-btn").addEventListener("click", getKeyValue);
            document.getElementById("delete-btn").addEventListener("click", deleteKeyValue);
            document.getElementById("set-replication-btn").addEventListener("click", setReplicationFactor);
            document.getElementById("replicate-key-btn").addEventListener("click", replicateKey);
            
            // Attach fault tolerance button handlers here
            document.getElementById("fail-node-btn").addEventListener("click", function() {
                const nodeId = document.getElementById('node-select').value;
                if (nodeId) {
                    failNode(nodeId);
                } else {
                    // Show a message if no node is selected
                    const statusEl = document.getElementById('fault-tolerance-status');
                    statusEl.textContent = 'Please select a node first';
                    statusEl.classList.remove('d-none', 'alert-success', 'alert-danger');
                    statusEl.classList.add('alert-warning');
                }
            });
            
            document.getElementById("recover-node-btn").addEventListener("click", function() {
                const nodeId = document.getElementById('node-select').value;
                if (nodeId) {
                    recoverNode(nodeId);
                } else {
                    // Show a message if no node is selected
                    const statusEl = document.getElementById('fault-tolerance-status');
                    statusEl.textContent = 'Please select a node first';
                    statusEl.classList.remove('d-none', 'alert-success', 'alert-danger');
                    statusEl.classList.add('alert-warning');
                }
            });
            
            // Fetch initial state
            fetchState();
            
            // Set up periodic refresh
            setInterval(fetchState, config.refreshInterval);
        }
        
        // Start the application when DOM is loaded
        document.addEventListener("DOMContentLoaded", init);

        // Fault Tolerance Functionality
        function updateNodeSelect() {
            console.log("===== UPDATE NODE SELECT =====");
            const nodeSelect = document.getElementById('node-select');
            const currentSelection = nodeSelect.value;
            console.log("Current selection:", currentSelection);
            console.log("Failed nodes:", state.failedNodes);
            
            // Clear select options
            nodeSelect.innerHTML = '';
            
            // Add an empty option for guidance
            const emptyOption = document.createElement('option');
            emptyOption.value = '';
            emptyOption.textContent = '--- Select a node ---';
            nodeSelect.appendChild(emptyOption);
            
            // Add options for each node
            if (state.nodes && Array.isArray(state.nodes)) {
                state.nodes.forEach(node => {
                    const option = document.createElement('option');
                    option.value = node.id;
                    
                    // Check if this node is in the failedNodes array
                    let isFailed = false;
                    if (state.failedNodes && Array.isArray(state.failedNodes)) {
                        console.log(`Checking if node ${node.id} is failed`);
                        isFailed = state.failedNodes.some(failedId => {
                            console.log(`  - Comparing with failed ID: ${failedId} (${typeof failedId}) vs ${node.id} (${typeof node.id})`);
                            const match = String(failedId) === String(node.id);
                            console.log(`  - Match: ${match}`);
                            return match;
                        });
                    }
                    
                    // Mark failed nodes in the dropdown text
                    if (isFailed) {
                        option.textContent = `${node.id} (Failed)`;
                        option.setAttribute('data-failed', 'true');
                        console.log(`Marking node ${node.id} as failed (data-failed=true)`);
                    } else {
                        option.textContent = `${node.id}`;
                        option.setAttribute('data-failed', 'false');
                        console.log(`Marking node ${node.id} as active (data-failed=false)`);
                    }
                    
                    nodeSelect.appendChild(option);
                });
            }
            
            // Restore previous selection if possible
            if (currentSelection) {
                for (let i = 0; i < nodeSelect.options.length; i++) {
                    if (nodeSelect.options[i].value === currentSelection) {
                        nodeSelect.selectedIndex = i;
                        break;
                    }
                }
            }
            
            // If no option is selected, select the first one
            if (nodeSelect.selectedIndex <= 0 && nodeSelect.options.length > 1) {
                nodeSelect.selectedIndex = 1;
            }
            
            // Log the current selected option
            const selectedOption = nodeSelect.options[nodeSelect.selectedIndex];
            if (selectedOption && selectedOption.value) {
                console.log("Selected option:", selectedOption.textContent);
                console.log("Selected option data-failed:", selectedOption.getAttribute('data-failed'));
            }
            
            // Manually trigger change event to update UI
            const event = new Event('change');
            nodeSelect.dispatchEvent(event);
            
            // Update button states based on the current selection
            updateButtonStates();
        }

        // Simplified function to update button states
        function updateButtonStates() {
            console.log("===== UPDATE BUTTON STATES =====");
            const nodeSelect = document.getElementById('node-select');
            const selectedNodeId = nodeSelect.value;
            
            // Get the buttons
            const failBtn = document.getElementById('fail-node-btn');
            const recoverBtn = document.getElementById('recover-node-btn');
            
            console.log("Selected node ID:", selectedNodeId);
            
            // Disable all buttons if no node is selected
            if (!selectedNodeId) {
                console.log("No node selected, disabling all buttons");
                if (failBtn) {
                    failBtn.disabled = true;
                    failBtn.setAttribute('disabled', 'disabled');
                    failBtn.classList.add('disabled-btn');
                    failBtn.classList.add('disabled');
                    failBtn.classList.remove('force-enable');
                }
                if (recoverBtn) {
                    recoverBtn.disabled = true;
                    recoverBtn.setAttribute('disabled', 'disabled');
                    recoverBtn.classList.add('disabled-btn');
                    recoverBtn.classList.add('disabled');
                    recoverBtn.classList.remove('force-enable');
                }
                return;
            }
            
            // Check if the selected node is in the failed nodes array
            let isFailed = false;
            if (state.failedNodes && Array.isArray(state.failedNodes)) {
                isFailed = state.failedNodes.some(failedId => 
                    String(failedId) === String(selectedNodeId)
                );
            }
            
            console.log("Is node failed:", isFailed);
            
            // IMPORTANT: When a node is failed, we want to:
            // 1. Disable the fail button (can't fail an already failed node)
            // 2. Enable the recover button (allow recovery of a failed node)
            
            // Handle fail button
            if (failBtn) {
                if (isFailed) {
                    // Disable fail button for failed nodes
                    console.log("DISABLING fail button for failed node:", selectedNodeId);
                    failBtn.disabled = true;
                    failBtn.setAttribute('disabled', 'disabled');
                    failBtn.classList.add('disabled-btn');
                    failBtn.classList.add('disabled');
                    failBtn.classList.remove('force-enable');
                } else {
                    // Enable fail button for active nodes
                    console.log("ENABLING fail button for active node:", selectedNodeId);
                    failBtn.disabled = false;
                    failBtn.removeAttribute('disabled');
                    failBtn.classList.remove('disabled-btn');
                    failBtn.classList.remove('disabled');
                }
            }
            
            // Handle recover button
            if (recoverBtn) {
                if (isFailed) {
                    // Enable recover button for failed nodes with strong override
                    console.log("ENABLING recover button for failed node:", selectedNodeId);
                    recoverBtn.disabled = false;
                    recoverBtn.removeAttribute('disabled');
                    recoverBtn.classList.remove('disabled-btn');
                    recoverBtn.classList.remove('disabled');
                    recoverBtn.classList.add('force-enable');  // Add extra force-enable class
                    
                    // Forcefully enable with direct style
                    recoverBtn.style.pointerEvents = 'auto';
                    recoverBtn.style.cursor = 'pointer';
                    recoverBtn.style.opacity = '1';
                } else {
                    // Disable recover button for active nodes
                    console.log("DISABLING recover button for active node:", selectedNodeId);
                    recoverBtn.disabled = true;
                    recoverBtn.setAttribute('disabled', 'disabled');
                    recoverBtn.classList.add('disabled-btn');
                    recoverBtn.classList.add('disabled');
                    recoverBtn.classList.remove('force-enable');
                    
                    // Reset any direct styles
                    recoverBtn.style.pointerEvents = '';
                    recoverBtn.style.cursor = '';
                    recoverBtn.style.opacity = '';
                }
            }
            
            // Log final states
            console.log("Final fail button state:", failBtn ? (failBtn.disabled ? "DISABLED" : "ENABLED") : "N/A");
            console.log("Final recover button state:", recoverBtn ? (recoverBtn.disabled ? "DISABLED" : "ENABLED") : "N/A");
        }

        // Function to directly force button states after a node fails or recovers
        function forceUpdateButtonsForFailedNode(nodeId, isFailed) {
            console.log(`FORCE UPDATE: Setting node ${nodeId} to ${isFailed ? 'FAILED' : 'ACTIVE'} state`);
            
            const failBtn = document.getElementById('fail-node-btn');
            const recoverBtn = document.getElementById('recover-node-btn');
            
            if (failBtn && recoverBtn) {
                if (isFailed) {
                    // Node is failed - disable fail button, enable recover button
                    console.log("FORCE: Disabling fail button, enabling recover button");
                    
                    // Disable fail button
                    failBtn.disabled = true;
                    failBtn.setAttribute('disabled', 'disabled');
                    failBtn.classList.add('disabled');
                    
                    // Enable recover button with !important override
                    recoverBtn.disabled = false;
                    recoverBtn.removeAttribute('disabled');
                    recoverBtn.classList.remove('disabled');
                    recoverBtn.classList.add('force-enable');
                    
                    // Apply direct styles
                    recoverBtn.style.opacity = '1';
                    recoverBtn.style.cursor = 'pointer';
                    recoverBtn.style.pointerEvents = 'auto';
                } else {
                    // Node is active - enable fail button, disable recover button
                    console.log("FORCE: Enabling fail button, disabling recover button");
                    
                    // Enable fail button
                    failBtn.disabled = false;
                    failBtn.removeAttribute('disabled');
                    failBtn.classList.remove('disabled');
                    
                    // Disable recover button
                    recoverBtn.disabled = true;
                    recoverBtn.setAttribute('disabled', 'disabled');
                    recoverBtn.classList.add('disabled');
                    recoverBtn.classList.remove('force-enable');
                    
                    // Reset direct styles
                    recoverBtn.style.opacity = '';
                    recoverBtn.style.cursor = '';
                    recoverBtn.style.pointerEvents = '';
                }
            }
        }

        // Function to fail a node
        async function failNode(nodeId) {
            try {
                // Show status
                const statusEl = document.getElementById('fault-tolerance-status');
                statusEl.textContent = `Attempting to fail node ${nodeId}...`;
                statusEl.classList.remove('d-none', 'alert-success', 'alert-danger');
                statusEl.classList.add('alert-info');
                
                const response = await fetch(`/api/node/fail/${nodeId}`, {
                    method: 'POST'
                });
                
                if (response.ok) {
                    console.log(`Node ${nodeId} marked as failed`);
                    document.getElementById("last-action").textContent = `Node ${nodeId} marked as failed`;
                    
                    // Show success status
                    statusEl.textContent = `Node ${nodeId} has been marked as FAILED successfully.`;
                    statusEl.classList.remove('alert-info', 'alert-danger');
                    statusEl.classList.add('alert-success');
                    
                    // Update button states immediately
                    const nodeSelect = document.getElementById('node-select');
                    const option = Array.from(nodeSelect.options).find(opt => opt.value === nodeId);
                    if (option) {
                        option.setAttribute('data-failed', 'true');
                        option.textContent = `${nodeId} (Failed)`;
                    }
                    
                    // Force update button states
                    forceUpdateButtonsForFailedNode(nodeId, true);
                    
                    // Refresh the state and UI
                    fetchState();
                } else {
                    const errorText = await response.text();
                    console.error('Error failing node:', errorText);
                    
                    // Show error status
                    statusEl.textContent = `Error failing node: ${errorText}`;
                    statusEl.classList.remove('alert-info', 'alert-success');
                    statusEl.classList.add('alert-danger');
                }
            } catch (error) {
                console.error('Error failing node:', error);
                
                // Show error status
                const statusEl = document.getElementById('fault-tolerance-status');
                statusEl.textContent = `Error failing node: ${error.message}`;
                statusEl.classList.remove('alert-info', 'alert-success', 'd-none');
                statusEl.classList.add('alert-danger');
            }
        }

        // Function to recover a node
        async function recoverNode(nodeId) {
            try {
                // Show status
                const statusEl = document.getElementById('fault-tolerance-status');
                statusEl.textContent = `Attempting to recover node ${nodeId}...`;
                statusEl.classList.remove('d-none', 'alert-success', 'alert-danger');
                statusEl.classList.add('alert-info');
                
                const response = await fetch(`/api/node/recover/${nodeId}`, {
                    method: 'POST'
                });
                
                if (response.ok) {
                    console.log(`Node ${nodeId} has recovered`);
                    document.getElementById("last-action").textContent = `Node ${nodeId} has recovered`;
                    
                    // Show success status
                    statusEl.textContent = `Node ${nodeId} has been RECOVERED successfully.`;
                    statusEl.classList.remove('alert-info', 'alert-danger');
                    statusEl.classList.add('alert-success');
                    
                    // Update button states immediately
                    const nodeSelect = document.getElementById('node-select');
                    const option = Array.from(nodeSelect.options).find(opt => opt.value === nodeId);
                    if (option) {
                        option.setAttribute('data-failed', 'false');
                        option.textContent = `${nodeId}`;
                    }
                    
                    // Force update button states
                    forceUpdateButtonsForFailedNode(nodeId, false);
                    
                    // Refresh the state and UI
                    fetchState();
                } else {
                    const errorText = await response.text();
                    console.error('Error recovering node:', errorText);
                    
                    // Show error status
                    statusEl.textContent = `Error recovering node: ${errorText}`;
                    statusEl.classList.remove('alert-info', 'alert-success');
                    statusEl.classList.add('alert-danger');
                }
            } catch (error) {
                console.error('Error recovering node:', error);
                
                // Show error status
                const statusEl = document.getElementById('fault-tolerance-status');
                statusEl.textContent = `Error recovering node: ${error.message}`;
                statusEl.classList.remove('alert-info', 'alert-success', 'd-none');
                statusEl.classList.add('alert-danger');
            }
        }

        // Add event listener for node select to update status display
        document.getElementById('node-select').addEventListener('change', function() {
            const nodeId = this.value;
            if (!nodeId) return;
            
            console.log("=== NODE SELECT CHANGED ===");
            console.log("Selected node ID:", nodeId);
            
            const statusEl = document.getElementById('fault-tolerance-status');
            const selectedOption = this.options[this.selectedIndex];
            const isFailed = selectedOption.getAttribute('data-failed') === 'true';
            
            console.log("Option selected:", selectedOption.textContent);
            console.log("Is failed (from attribute):", isFailed);
            console.log("data-failed attribute value:", selectedOption.getAttribute('data-failed'));
            
            // Check against state.failedNodes array as well
            let isInFailedArray = false;
            if (state.failedNodes && Array.isArray(state.failedNodes)) {
                isInFailedArray = state.failedNodes.some(failedId => String(failedId) === String(nodeId));
                console.log("Is in failedNodes array:", isInFailedArray);
                console.log("failedNodes array:", state.failedNodes);
            }
            
            // Update status message
            if (isFailed) {
                statusEl.textContent = `Node ${nodeId} is currently FAILED. You can recover it.`;
                statusEl.classList.remove('d-none', 'alert-success', 'alert-info');
                statusEl.classList.add('alert-warning');
                
                // Force enable recover button for failed nodes
                forceUpdateButtonsForFailedNode(nodeId, true);
            } else {
                statusEl.textContent = `Node ${nodeId} is ACTIVE. You can simulate failure.`;
                statusEl.classList.remove('d-none', 'alert-warning', 'alert-danger');
                statusEl.classList.add('alert-success');
                
                // Force disable recover button for active nodes
                forceUpdateButtonsForFailedNode(nodeId, false);
            }
            
            // Get button elements and log their state after update
            const failBtn = document.getElementById('fail-node-btn');
            const recoverBtn = document.getElementById('recover-node-btn');
            console.log("After direct update - Fail button disabled:", failBtn ? failBtn.disabled : "N/A");
            console.log("After direct update - Recover button disabled:", recoverBtn ? recoverBtn.disabled : "N/A");
        });

        // Update visualization for failed nodes
        function updateNodesForFaultTolerance(nodeElements) {
            nodeElements.classed('failed-node', d => {
                return state.failedNodes && state.failedNodes.some(failedNodeId => 
                    String(failedNodeId) === String(d.id)
                );
            });
            
            // Add different coloration for failed nodes
            nodeElements.select('rect')
                .style('fill', d => {
                    return state.failedNodes && state.failedNodes.some(failedNodeId => 
                        String(failedNodeId) === String(d.id)
                    ) 
                        ? '#f44336' // Red for failed nodes
                        : '#4CAF50'; // Green for active nodes
                })
                .style('stroke-dasharray', d => {
                    return state.failedNodes && state.failedNodes.some(failedNodeId => 
                        String(failedNodeId) === String(d.id)
                    ) 
                        ? '5,5' : 'none';
                });
                
            // Update node labels to show failed status
            nodeElements.select('text')
                .text(d => {
                    const isFailed = state.failedNodes && state.failedNodes.some(failedNodeId => 
                        String(failedNodeId) === String(d.id)
                    );
                    return d.id + (isFailed ? ' (FAILED)' : '');
                });
        }

        // Add CSS for failed nodes
        const styleElement = document.createElement('style');
        styleElement.textContent = `
            .failed-node rect {
                fill: #f44336 !important;
                stroke-dasharray: 5,5;
                animation: pulse 2s infinite;
            }
            
            @keyframes pulse {
                0% { opacity: 0.8; }
                50% { opacity: 0.4; }
                100% { opacity: 0.8; }
            }
        `;
        document.head.appendChild(styleElement);

        // Update the drawNode function to include fault tolerance visualization
        function drawNode(node) {
            const nodeElement = svg.append('g')
                .attr('class', 'node')
                .attr('id', `node-${node.id}`);
            
            // Check if the node is failed
            const isFailed = state.failedNodes && state.failedNodes.some(failedNodeId => 
                String(failedNodeId) === String(node.id)
            );
            
            // Add node zone rectangle
            nodeElement.append('rect')
                .attr('x', xAxis(node.zone.minPoint[0]))
                .attr('y', yAxis(node.zone.minPoint[1]))
                .attr('width', xAxis(node.zone.maxPoint[0]) - xAxis(node.zone.minPoint[0]))
                .attr('height', yAxis(node.zone.maxPoint[1]) - yAxis(node.zone.minPoint[1]))
                .attr('fill', isFailed ? '#f44336' : '#4CAF50')
                .attr('fill-opacity', 0.3)
                .attr('stroke', '#333')
                .attr('stroke-width', 1)
                .attr('stroke-dasharray', isFailed ? '5,5' : 'none');
            
            // Add node label
            nodeElement.append('text')
                .attr('class', 'node-label')
                .attr('x', xAxis((node.zone.minPoint[0] + node.zone.maxPoint[0]) / 2))
                .attr('y', yAxis((node.zone.minPoint[1] + node.zone.maxPoint[1]) / 2))
                .text(node.id + (isFailed ? ' (FAILED)' : ''));
            
            return nodeElement;
        }

        // Add function to highlight keys on failed nodes
        function highlightKeysOnFailedNodes() {
            if (!state.keyValuePairs || !state.failedNodes) return;
            
            // Mark keys on failed nodes for special treatment
            state.keyValuePairs.forEach(kv => {
                kv.onFailedNode = state.failedNodes.some(failedNodeId => 
                    String(failedNodeId) === String(kv.NodeID)
                );
                
                // Check if this key has a healthy replica
                if (kv.IsPrimaryCopy && kv.onFailedNode) {
                    kv.hasHealthyReplica = false;
                    
                    // Check if any replicas are on healthy nodes
                    if (kv.ReplicaNodes && kv.ReplicaNodes.length > 0) {
                        for (const replicaNodeId of kv.ReplicaNodes) {
                            const replicaIsFailed = state.failedNodes.some(failedNodeId => 
                                String(failedNodeId) === String(replicaNodeId)
                            );
                            
                            if (!replicaIsFailed) {
                                kv.hasHealthyReplica = true;
                                break;
                            }
                        }
                    }
                }
            });
        }
        
        // Extend the key rendering to show keys on failed nodes differently
        const originalUpdateVisualization = updateVisualization;
        updateVisualization = function() {
            // Call the original function
            originalUpdateVisualization();
            
            // Update key styling based on failed node status
            keysGroup.selectAll('.key')
                .attr('stroke-width', d => {
                    if (d.onFailedNode) {
                        return d.IsPrimaryCopy ? 3 : 2;
                    }
                    return d.IsPrimaryCopy ? config.primaryStrokeWidth : config.replicaStrokeWidth;
                })
                .attr('stroke', d => {
                    if (d.onFailedNode) {
                        return d.hasHealthyReplica ? '#ff9800' : '#f44336'; // Orange if replica exists, red if not
                    }
                    return d.IsPrimaryCopy ? config.primaryStroke : config.replicaStroke;
                })
                .attr('stroke-dasharray', d => d.onFailedNode ? '3,3' : 'none');
        };
    </script>
</body>
</html> 